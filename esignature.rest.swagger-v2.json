{
  "swagger": "2.0",
  "info": {
    "version": "v1",
    "title": "ProofService API"
  },
  "paths": {
    "/api/v1.0/events/{entityType}/{entityId}.{format}": {
      "get": {
        "tags": [
          "Events"
        ],
        "summary": "Returns a list of events for a specific entity. ",
        "operationId": "ApiByVersionEventsByEntityTypeByEntityIdFormat",
        "consumes": [],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "entityType",
            "in": "path",
            "description": "The type of the entity (for example room, user or envelope). ID Evidence only supports the \\\"person\\\" (recipient) entity type. Optional.",
            "required": true,
            "type": "string"
          },
          {
            "name": "entityId",
            "in": "path",
            "description": "The id of the DocuSign entity. Optional.",
            "required": true,
            "type": "string",
            "format": "uuid"
          },
          {
            "name": "actor_id",
            "in": "query",
            "description": "*This parameter is not used with ID Evidence.*",
            "required": false,
            "type": "string"
          },
          {
            "name": "from_date",
            "in": "query",
            "description": "Retrieves all the events created from the specified date. This date is inclusive. \r\nIf empty, then all the events created up until the *to_date* value are returned.",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "to_date",
            "in": "query",
            "description": "Retrieves all the events created until the specified date. This date is inclusive. \r\nIf empty, then all the events created from the from_date are returned.",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "include_media",
            "in": "query",
            "description": "Indicates whether you want to include the media in the response. \r\nThe media depends on the event returned by the ID Evidence API. \r\nFor example, ID Evidence can return the capture of the ID uploaded for verification. \r\nNote that including the media in the response may carry a large amount of data. \r\nIf set to *false*, then the request returns a link that you can use later with the Get Media request to retrieve the media file.",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "page_index",
            "in": "query",
            "description": "The index position of the currently displayed page.",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "page_size",
            "in": "query",
            "description": "The number of records to display on a page.",
            "required": false,
            "type": "integer",
            "format": "int32",
            "maximum": 2147483647,
            "minimum": 0
          },
          {
            "name": "format",
            "in": "path",
            "required": true,
            "type": "string",
            "description": "The format of the content in the response. The supported formats are: json, html, and pdf."
          },
          {
            "name": "version",
            "in": "path",
            "description": "The requested API version",
            "required": true,
            "type": "string",
            "default": "1.0"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "$ref": "#/definitions/IEventsResponse"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "406": {
            "description": "Not Acceptable",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "412": {
            "description": "Client Error",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "415": {
            "description": "Client Error",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          }
        },
        "x-ds-method": "list",
        "x-ds-methodname": "listEventsByEntityIdFormat",
        "x-ds-service": "Events",
        "description": "Returns a list of events for a specific recipient. You can filter the results by specifying additional criteria.    \n**Note**: This method supersedes the older `GET /api/v1.0/events/{entityType}/{entityId}` request. You can still use the old `GET` request but we highly recommend you switch to this method which provides improved output capabilities.",
        "x-ds-in-sdk": true
      }
    },
    "/api/v1.0/events/{entityType}/{entityId}/{eventId}/media/{mediaId}": {
      "get": {
        "tags": [
          "Events"
        ],
        "summary": "Gets the media item related to a specific event.",
        "operationId": "ApiByVersionEventsByEntityTypeByEntityIdByEventIdMediaByMediaIdGet",
        "consumes": [],
        "produces": [
          "text/plain"
        ],
        "parameters": [
          {
            "name": "eventId",
            "in": "path",
            "description": "The id of the event as recorded in the database. Optional.",
            "required": true,
            "type": "string",
            "format": "uuid"
          },
          {
            "name": "mediaId",
            "in": "path",
            "description": "The id of the media associated with the event. Optional.",
            "required": true,
            "type": "string",
            "format": "uuid"
          },
          {
            "name": "entityType",
            "in": "path",
            "description": "The type of the entity (for example room, user or envelope). ID Evidence only supports the \\\"person\\\" (recipient) entity type. Optional.",
            "required": true,
            "type": "string"
          },
          {
            "name": "entityId",
            "in": "path",
            "description": "The id of the DocuSign entity. Optional.",
            "required": true,
            "type": "string",
            "format": "uuid"
          },
          {
            "name": "version",
            "in": "path",
            "description": "The requested API version",
            "required": true,
            "type": "string",
            "default": "1.0"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "schema": {
              "type": "object"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "401": {
            "description": "Unauthorized",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "403": {
            "description": "Forbidden",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "404": {
            "description": "Not Found",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          },
          "412": {
            "description": "Client Error",
            "schema": {
              "$ref": "#/definitions/HttpErrorResponse"
            }
          }
        },
        "x-ds-method": "getMedia",
        "x-ds-methodname": "getMedia",
        "x-ds-service": "Events",
        "description": "Gets the media item related to a specific event. This call is built using the response to the Get Events request (see the include_media parameter).",
        "x-ds-in-sdk": true
      }
    }
  },
  "definitions": {
    "HttpErrorResponse": {
      "description": "Object defining an error returned in an http response.",
      "type": "object",
      "properties": {
        "error": {
          "description": "The code associated with the error condition.",
          "enum": [
            "internal_server_error",
            "unauthorized",
            "unauthorized_strong_auth_required",
            "unauthorized_recent_creds_required",
            "unauthorized_strong_auth_and_recent_creds_required",
            "unauthorized_jwt_bearer_required",
            "invalid_request_parameter_value",
            "consent_required",
            "proof_locked",
            "user_locked",
            "not_enough_proofs_for_tfa",
            "no_code_submitted",
            "invalid_channel",
            "tfa_voice_blocked",
            "proof_already_exists",
            "too_many_proofs",
            "too_many_authenticator_apps",
            "timespan_out_of_range",
            "cant_delete_primary_email_proof",
            "password_change_not_allowed",
            "email_change_not_allowed",
            "cannot_use_same_email",
            "invalid_code",
            "invalid_organization",
            "invalid_organization_name",
            "organization_default_account_cannot_be_deleted",
            "invalid_organization_admin",
            "invalid_organization_admin_user",
            "organization_admin_cannot_remove_self",
            "admin_email_already_mapped_to_organization",
            "admin_user_already_mapped_to_organization",
            "invalid_organization_account",
            "account_already_mapped_to_an_organization",
            "invalid_account",
            "invalid_permission_profile",
            "invalid_member_group",
            "invalid_language_culture",
            "invalid_password_reset_inactive_user",
            "invalid_password_reset_federated_user",
            "invalid_email_change_already_in_use",
            "invalid_email_change_federated_user",
            "invalid_email_change_domain_reserved",
            "max_keys_allowed",
            "invalid_user",
            "invalid_grant",
            "invalid_request",
            "no_recovery_info_found",
            "user_not_found",
            "UserNotFound",
            "invalid_term",
            "invalid_production_account_id",
            "production_account_id_not_admin",
            "envelope_not_sent",
            "password_change_validation_failed",
            "password_validation_questions_count",
            "password_validation_complexity",
            "password_validation_history",
            "password_validation_banned",
            "sso_not_allowed",
            "username_email_awaiting_activation",
            "invalid_email_address",
            "invalid_send_activation_request",
            "invalid_organization_default_account",
            "signup_invalid_invite_token",
            "invite_not_enabled_for_client",
            "username_email_already_exists",
            "IdentityProviderFriendlyNameAlreadyInUse",
            "IdentityProviderIssuerAlreadyInUse",
            "IdentityProviderInsertFailed",
            "invalid_user_default_account",
            "max_members_reached",
            "invalid_locale",
            "OrganizationReservedDomainVerifyFailed",
            "OrganizationInvalid",
            "OrganizationReservedDomainInvalidHostName",
            "OrganizationReservedDomainInsertFailed",
            "OrganizationReservedDomainHostNameMismatch",
            "OrganizationReservedDomainInvalid",
            "OrganizationReservedDomainNotFound",
            "OrganizationOrganizationReservedDomainMismatch",
            "InvalidModel",
            "ClientApplicationMaxReached",
            "ClientApplicationDuplicateClientID",
            "ClientApplicationInsertFailed",
            "ClientApplicationDeleteFailed",
            "IdentityProviderInvalid",
            "IdentityProviderCertificateInvalid",
            "IdentityProviderCertificateMismatch",
            "IdentityProviderNotFound",
            "OrganizationIdentityProviderMismatch",
            "missing_identity_provider_ids",
            "AppReviewJobNotFound",
            "AppReviewJobInsertFailed",
            "AppReviewJobExpired",
            "ReactivationOfRedundantMembership",
            "appliance_pool_internal_server_error",
            "cannot_delete_referenced_appliance_pool",
            "cannot_delete_last_appliance",
            "appliance_type_mismatch",
            "invalid_appliance_id",
            "appliance_pool_id_mismatch",
            "appliance_pool_id_invalid",
            "organization_id_mismatch",
            "invalid_appliance_type",
            "not_legacy_account",
            "account_already_linked",
            "no_appliance_in_pool",
            "appliance_type_endpoint_mismatch",
            "invalid_appliance_status",
            "invalid_organization_id",
            "appliance_add_error",
            "appliance_update_error",
            "appliance_get_legacy_error",
            "appliance_get_pool_summary_error",
            "appliance_health_check_error",
            "appliance_account_has_used_pool_error",
            "user_identity_not_found",
            "partner_not_found",
            "invalid_plan_id",
            "invalid_distributor_code",
            "invalid_account_name",
            "create_account_error",
            "order_search_invalid",
            "invalid_account_id",
            "invalid_account_address",
            "invalid_account_admin_user",
            "partner_account_user_exists",
            "partner_account_email_reserved",
            "partner_account_domain_managed_by_identity_provider",
            "partner_account_email_has_free_trial",
            "partner_account_error",
            "account_not_associated_with_partner",
            "account_not_found",
            "account_closed",
            "partner_billing_event_not_found",
            "partner_event_not_found",
            "invalid_partner_id",
            "invalid_event_type",
            "invalid_status",
            "invalid_retry_count",
            "partner_id_cannot_be_updated",
            "event_type_cannot_be_updated",
            "event_date_cannot_be_updated",
            "event_trace_token_cannot_be_updated",
            "event_correlation_id_cannot_be_updated",
            "event_properties_cannot_be_updated",
            "event_properties_cannot_be_added",
            "invalid_client_id",
            "client_not_found",
            "plan_not_found",
            "partner_has_no_plans",
            "plan_not_supported",
            "invalid_role_name",
            "role_not_found",
            "invalid_partner_name",
            "partner_name_not_found",
            "invalid_user_id",
            "invalid_role_id",
            "invalid_role",
            "partner_id_mismatch",
            "invalid_account_seats",
            "duplicate_account",
            "invalid_address",
            "invalid_country",
            "invalid_state_province",
            "invalid_plan_configuration",
            "invalid_product_rate_plan",
            "invalid_included_seats",
            "invalid_organization_permission",
            "invalid_cancellation_reason",
            "cancellation_date_not_set",
            "directory_provider_not_found",
            "directory_provider_feature_already_in_use",
            "directory_provider_already_activated",
            "directory_provider_organization_entitlement_is_not_allowed",
            "invalid_azure_admin",
            "invalid_query",
            "invalid_organization_delegated_admin",
            "delegated_admin_already_exists",
            "insufficient_organization_delegated_permission",
            "managed_token_not_found",
            "managed_token_update_blocked",
            "managed_token_update_notpersisted",
            "managed_token_redemption_failure",
            "managed_token_already_exists",
            "managed_token_mismatched_subject_type",
            "managed_token_expiration_in_past",
            "managed_token_invalid_externalclaims",
            "managed_token_resources_too_large",
            "redirect_uri_not_registered",
            "scopes_invalid",
            "non_userbased_token",
            "userinvite_not_found",
            "userinvite_invalid_token",
            "userinvite_invalid_response_type",
            "userinvite_invalid_email",
            "managedtoken_load_failed",
            "managedtoken_create_failed",
            "managedtoken_revoke_failed",
            "resourcetoken_redeem_failed",
            "servicetoken_load_failed",
            "userinvite_already_exists",
            "userinvite_unmanaged_membership_not_allowed",
            "userinvite_account_not_found",
            "userinvite_user_mismatch",
            "userinvite_account_not_active",
            "userinvite_user_not_found",
            "userinvite_invalid_use_selection",
            "userinvite_membership_already_exists",
            "userinvite_bad_request",
            "userinvite_request_secret_uri_not_enabled",
            "signup_state_too_large",
            "signup_invalid_locale",
            "too_many_tokens_per_resource_id",
            "redirect_uri_used_for_external_claims",
            "invalid_account_status_for_action",
            "max_audit_log_page_size_exceeded",
            "invalid_audit_log_paging_request",
            "address_does_not_exist",
            "invalid_user_name",
            "invalid_user_status",
            "partner_missing_properties",
            "partner_customer_invalid_license_information",
            "partner_license_callback_failed",
            "partner_certificate_callback_failed",
            "partner_oauth_callback_failed",
            "invalid_notification_type",
            "invalid_default_account_id",
            "user_not_a_member_of_account",
            "organization_export_requests_pending",
            "organization_export_type_invalid",
            "organization_export_request_not_found",
            "organization_export_task_processing_timeout",
            "organization_export_task_queued_timeout",
            "organization_export_task_max_allowed",
            "organization_export_task_invalid_resultsetstorage",
            "organization_import_not_found",
            "organization_import_bad_request_header",
            "organization_import_bad_csv_content",
            "invalid_id_request",
            "invalid_eid_request",
            "organization_export_task_not_found",
            "proof_service_validation_model_not_found",
            "organization_import_processing_timeout",
            "proof_service_invalid_model_type",
            "proof_service_proof_file_not_exists",
            "proof_service_proof_file_bad_owner",
            "proof_service_model_validation_failure",
            "proof_service_request_entity_too_large",
            "proof_service_unreadable_payload",
            "proof_service_view_schema_invalid",
            "proof_service_front_view_not_exists",
            "proof_service_view_schema_not_found",
            "proof_service_event_not_found",
            "proof_service_event_media_not_found",
            "proof_service_event_media_unauthorized",
            "proof_service_error",
            "proof_service_proof_file_duplicate",
            "proof_service_schema_conflict",
            "proof_service_view_conflict",
            "forbidden",
            "invalid_photoid_request",
            "invalid_identityweb_resource_request",
            "identityweb_manual_review_disabled",
            "identityweb_vendor_response_validation_failed",
            "organization_import_no_csv_results",
            "organization_import_export_pending",
            "organization_export_import_pending",
            "organization_import_delete_status_queued",
            "organization_import_max_records",
            "organization_import_max_total_records",
            "organization_import_max_account_records",
            "organization_import_max_site_records",
            "organization_import_max_accounts",
            "organization_import_could_not_be_queued",
            "organization_import_import_pending",
            "organization_import_max_imports",
            "principal_throttled",
            "service_unavailable",
            "invalid_template",
            "invalid_admin_communication_principal",
            "invalid_admin_communication",
            "max_admin_communication_aggregations_exceeded",
            "missing_admin_communication_subject",
            "unable_to_send_orgadmin_invitation",
            "order_already_exists",
            "order_not_found",
            "order_invalid_product_state",
            "order_invalid_state",
            "accountproduct_account_not_found",
            "invalid_accountproduct",
            "accountproduct_update_failed",
            "accountproduct_provision_failed",
            "freetrial_alreay_claimed",
            "accountproduct_activation_failed",
            "provision_token_create_failed",
            "order_free_trial_already_claimed",
            "transaction_management_client_error",
            "transaction_management_service_error",
            "provision_client_failed",
            "accountproduct_cancellation_failed",
            "accountproduct_upgrade_failed",
            "account_information_not_specified",
            "appliance_latest_release_error",
            "appliance_release_error",
            "appliance_release_file_error",
            "auto_activate_member_in_non_active_account",
            "organization_export_domain_selection_invalid",
            "organization_export_account_selection_invalid",
            "invalid_metadata",
            "organization_disallowed_for_account",
            "unable_to_send_orgaccount_invitation",
            "unsupported_principal_type",
            "invalid_phone_number",
            "identity_session_creation_error",
            "invalid_mapping_code",
            "create_mobile_session_throttled",
            "identity_client_logging_error",
            "organization_account_settings_import_imports_pending",
            "organization_account_settings_import_exports_pending",
            "organization_export_account_settings_import_pending",
            "declined_invitation_update_not_allowed",
            "accepted_invitation_access_not_allowed",
            "missing_current_authenticated_principal_information",
            "invalid_caller_information",
            "public_key_insert_header_content_invalid",
            "public_key_insert_user_public_key_already_existed",
            "public_key_insert_unable_to_read_public_key",
            "public_key_insert_unable_to_locate_public_key",
            "public_key_insert_empty_request_body",
            "public_key_unable_to_process_public_key",
            "public_key_not_found",
            "public_key_id_empty",
            "public_key_id_invalid",
            "public_key_content_invalid",
            "public_key_not_supported",
            "public_key_malformatted",
            "account_update_failed",
            "account_change_plan_failed",
            "account_creation_failed",
            "accountproduct_invalid_status",
            "accountproduct_not_exist",
            "accountproduct_expire_failed",
            "proofservice_management_disabled",
            "invalid_product",
            "not_supported",
            "identity_workflow_not_found",
            "identity_workflow_signature_method_not_found",
            "identity_workflow_claim_unknown_provider_type",
            "identity_workflow_invalid_externalclaim_properties",
            "public_key_api_invalid_modulus",
            "public_key_api_invalid_exponent",
            "public_key_api_invalid_public_key",
            "public_key_api_no_user_mapping_to_given_public_key",
            "duplicate_unit_of_measure",
            "membership_close_not_allowed",
            "immutableid_already_exists",
            "organization_has_no_verified_reserved_domains",
            "get_account_groups_failed",
            "organization_missing_entitlement",
            "config_missing_apps_or_values",
            "missing_pen_required_claims",
            "account_sync_failed",
            "invalid_uri",
            "invalid_site",
            "provision_rest_client_error",
            "product_master_entry_not_found",
            "provision_orderservicev2_bad_request",
            "linked_identity_provider_record_not_found",
            "accountproduct_freetrial_not_eligible",
            "order_invalid_product",
            "protect_api_invalid_action_context",
            "protect_api_rules_error",
            "protect_api_invalid_recaptcha_configuration",
            "protect_api_invalid_recaptcha_verification_error",
            "protect_api_invalid_config",
            "protect_api_approval_error",
            "order_invalid_account",
            "order_invalid_source",
            "order_invalid_user",
            "provision_queue_failure",
            "invalid_organization_entitlement",
            "product_master_invalid_external_key",
            "product_master_entry_invalid_internal_id",
            "order_provision_failed",
            "protect_api_report_abuse_request_error",
            "protect_api_report_abuse_email_error",
            "protect_api_report_abuse_error",
            "protect_api_report_abuse_config_error",
            "protect_api_report_abuse_web_error",
            "invalid_region",
            "billing_profile_get_failed",
            "current_plan_get_failed",
            "billing_profile_update_failed",
            "billing_profile_account_not_found",
            "billing_profile_account_plan_not_found",
            "billing_profile_invalid_currency",
            "billing_profile_invalid_zuora_id",
            "billing_profile_invalid_external_billing_system_id",
            "billing_profile_external_billing_usage_start_date_required",
            "billing_profile_accountbilling_active_required",
            "feature_disabled_in_jump_to_mobile_session",
            "requested_format_mismatch",
            "organization_entitlement_invalid_rights",
            "invalid_image"
          ],
          "type": "string"
        },
        "error_description": {
          "description": "A brief message describing the error condition.",
          "type": "string"
        },
        "service_error_code": {
          "description": "The service error code.",
          "type": "string"
        },
        "reference_id": {
          "description": "The reference identifier corresponding to the trace token.",
          "type": "string",
          "readOnly": true
        },
        "error_stack": {
          "description": "The error stacktrace.",
          "type": "string"
        },
        "error_inner": {
          "description": "The previous exceptions in the call stack.",
          "type": "string"
        }
      },
      "x-ds-definition-name": "HttpErrorResponse",
      "x-ms-summary": "Object defining an error returned in an http response."
    },
    "IEventsResponse": {
      "description": "Definition of a transaction. It contains the list of the events and some metadata.",
      "type": "object",
      "properties": {
        "events": {
          "description": "List of the events contained in the transaction.",
          "uniqueItems": false,
          "type": "array",
          "items": {
            "$ref": "#/definitions/IEventResponse"
          },
          "readOnly": true
        },
        "paging": {
          "$ref": "#/definitions/IPaginated",
          "description": "Paging info.",
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IEventsResponse",
      "x-ms-summary": "Definition of a transaction. It contains the list of the events and some metadata."
    },
    "IEventResponse": {
      "description": "Definition of a simple event item. The transaction hold by the proof file is made of a list of these items.",
      "type": "object",
      "properties": {
        "event_type": {
          "description": "Type of the event.",
          "type": "string",
          "readOnly": true
        },
        "creation_date": {
          "format": "date-time",
          "description": "The date the event was created. This information is useful for filtering events.",
          "type": "string",
          "readOnly": true
        },
        "actor_id": {
          "description": "The id of the actor.",
          "type": "string",
          "readOnly": true
        },
        "data": {
          "description": "The event data that is inserted by  ID Evidence.",
          "type": "object",
          "readOnly": true
        },
        "has_media": {
          "description": "Indicates whether the object contains large media objects in its data.",
          "type": "boolean",
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IEventResponse",
      "x-ms-summary": "Definition of a simple event item. The transaction hold by the proof file is made of a list of these items."
    },
    "IPaginated": {
      "description": "Interface defining the paging properties.",
      "type": "object",
      "properties": {
        "pageIndex": {
          "format": "int32",
          "description": "The index position of the page.",
          "type": "integer",
          "readOnly": true
        },
        "pageSize": {
          "format": "int32",
          "description": "The size of the page.",
          "type": "integer",
          "readOnly": true
        },
        "totalPages": {
          "format": "int32",
          "description": "The total number of pages in the response.",
          "type": "integer",
          "readOnly": true
        },
        "totalItems": {
          "format": "int32",
          "description": "The total number of items responding to the request.",
          "type": "integer",
          "readOnly": true
        },
        "hasPreviousPage": {
          "description": "Indicates whether this object can call a previous page.",
          "type": "boolean",
          "readOnly": true
        },
        "hasNextPage": {
          "description": "Indicates whether this object can call a next page.",
          "type": "boolean",
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IPaginated",
      "x-ms-summary": "Interface defining the paging properties."
    },
    "PostEventBody": {
      "description": "Model representing the object passed to the set event endpoint.",
      "required": [
        "event_type",
        "payload_model_version"
      ],
      "type": "object",
      "properties": {
        "event_type": {
          "description": "Type of the event added to the list of events tied to the transaction. A schema validating this kind of event must have been created in a first place.",
          "type": "string"
        },
        "actor_id": {
          "description": "Actor identifier. This enables to attach this event to a particular actor.",
          "type": "string"
        },
        "payload": {
          "description": "This parameter is formed by a json containing all relevant information about the event. This Json must match a particular structure defined by the type of the event and the type of the entity (see validation schemas).",
          "type": "object"
        },
        "payload_model_version": {
          "format": "int32",
          "description": "Version of the validation model. Each model is versioned.",
          "maximum": 2147483647,
          "minimum": 0,
          "type": "integer"
        }
      },
      "x-ds-definition-name": "PostEventBody",
      "x-ms-summary": "Model representing the object passed to the set event endpoint."
    },
    "IPostEventResponse": {
      "description": "Defined an event added to a transaction.",
      "type": "object",
      "properties": {
        "entity_id": {
          "format": "uuid",
          "description": "The DocuSign entity identifier.",
          "type": "string",
          "readOnly": true
        },
        "entity_type": {
          "description": "Type of the entity. i.e room, user, envelope...",
          "type": "string",
          "readOnly": true
        },
        "event_type": {
          "description": "Type of the event added to the list of events tied to the transaction.",
          "type": "string",
          "readOnly": true
        },
        "actor_id": {
          "description": "Actor identifier. This enables to attach this event to a particular actor.",
          "type": "string",
          "readOnly": true
        },
        "payload_schema_version": {
          "format": "int32",
          "description": "Version of the validation schema used to check the data structure integrity.",
          "type": "integer",
          "readOnly": true
        },
        "created_date": {
          "format": "date-time",
          "description": "Creation date of the entity calculated by the server.",
          "type": "string",
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IPostEventResponse",
      "x-ms-summary": "Defined an event added to a transaction."
    },
    "DeleteEventsBody": {
      "description": "Model representing the object passed to the delete event endpoint.",
      "type": "object",
      "properties": {
        "event_id": {
          "format": "uuid",
          "description": "Event identifier. If you get it, it can be a shortcut to delete only one event.",
          "type": "string"
        },
        "client_id": {
          "description": "Client identifier of the user that has inserted the event.",
          "type": "string"
        },
        "event_type": {
          "description": "Type of the event added to the list of events tied to the transaction.",
          "type": "string"
        },
        "actor_id": {
          "description": "Actor identifier. This enables to remove the events only related to a particular actor.",
          "type": "string"
        }
      },
      "x-ds-definition-name": "DeleteEventsBody",
      "x-ms-summary": "Model representing the object passed to the delete event endpoint."
    },
    "IFrontViewsResponse": {
      "description": "",
      "type": "object",
      "properties": {
        "front_views": {
          "description": "List of the front view.",
          "uniqueItems": true,
          "type": "array",
          "items": {
            "$ref": "#/definitions/IFrontViewResponse"
          },
          "readOnly": true
        },
        "paging": {
          "$ref": "#/definitions/IPaginated",
          "description": "Paging info.",
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IFrontViewsResponse",
      "x-ms-summary": ""
    },
    "IFrontViewResponse": {
      "description": "Definition of a front view",
      "type": "object",
      "properties": {
        "front_view_id": {
          "format": "uuid",
          "description": "Front view identifier.",
          "type": "string",
          "readOnly": true
        },
        "view_name": {
          "description": "Name of the view in the Proof WebApp.",
          "type": "string",
          "readOnly": true
        },
        "events_types": {
          "description": "List of events types that are bound to a proof webapp view.",
          "uniqueItems": false,
          "type": "array",
          "items": {
            "type": "string"
          },
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IFrontViewResponse",
      "x-ms-summary": "Definition of a front view"
    },
    "PostFrontViewBody": {
      "description": "Model representing the object passed to the create front view endpoint.",
      "required": [
        "events_types"
      ],
      "type": "object",
      "properties": {
        "events_types": {
          "description": "List of events types that are bound to a proof webapp view. These events types must be those we will use in the insertion of events.",
          "uniqueItems": true,
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "x-ds-definition-name": "PostFrontViewBody",
      "x-ms-summary": "Model representing the object passed to the create front view endpoint."
    },
    "PutFrontViewBody": {
      "description": "Model representing the object passed to the update front view endpoint.",
      "required": [
        "events_types"
      ],
      "type": "object",
      "properties": {
        "events_types": {
          "description": "List of events types that are bound to a proof webapp view. These events types must be those we will use in the insertion of events.",
          "uniqueItems": true,
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "x-ds-definition-name": "PutFrontViewBody",
      "x-ms-summary": "Model representing the object passed to the update front view endpoint."
    },
    "GenerateProofFileLinkBody": {
      "description": "Model representing the object passed to the GenerateProofFileLink endpoint.",
      "required": [
        "view_name",
        "authority"
      ],
      "type": "object",
      "properties": {
        "actor_id": {
          "description": "Actor identifier",
          "type": "string"
        },
        "view_name": {
          "description": "ViewName of the WebApp called",
          "type": "string"
        },
        "authority": {
          "description": "Name of the authority requesting these events. The rendering differs according to the accreditation level that this authority has.",
          "type": "string"
        }
      },
      "x-ds-definition-name": "GenerateProofFileLinkBody",
      "x-ms-summary": "Model representing the object passed to the GenerateProofFileLink endpoint."
    },
    "GenerateProofFileLinkResponse": {
      "description": "Definition of the object that is used as a response of a managed token.",
      "type": "object",
      "properties": {
        "secret_uri": {
          "description": "Secret URI generated and containing the managed token.",
          "type": "string"
        }
      },
      "x-ds-definition-name": "GenerateProofFileLinkResponse",
      "x-ms-summary": "Definition of the object that is used as a response of a managed token."
    },
    "GetResourceTokenBody": {
      "description": "Model representing the object passed to the GetResourceToken endpoint.",
      "required": [
        "view_name",
        "authority",
        "scopes"
      ],
      "type": "object",
      "properties": {
        "actor_id": {
          "description": "Actor identifier",
          "type": "string"
        },
        "view_name": {
          "description": "ViewName of the WebApp called",
          "type": "string"
        },
        "authority": {
          "description": "Name of the authority requesting these events. The rendering differs according to the accreditation level that this authority has.",
          "type": "string"
        },
        "scopes": {
          "description": "Scopes assign to the resource token. It represent the action the resource token is bound to. The resource token can be apply to get the events or to redact a proof file.",
          "uniqueItems": false,
          "type": "array",
          "items": {
            "enum": [
              "GetEvents",
              "RedactProofFile"
            ],
            "type": "string"
          }
        }
      },
      "x-ds-definition-name": "GetResourceTokenBody",
      "x-ms-summary": "Model representing the object passed to the GetResourceToken endpoint."
    },
    "GetResourceTokenResponse": {
      "description": "Definition of the object that is used as a response of a managed token.",
      "type": "object",
      "properties": {
        "resource_token": {
          "description": "Resource token.",
          "type": "string"
        }
      },
      "x-ds-definition-name": "GetResourceTokenResponse",
      "x-ms-summary": "Definition of the object that is used as a response of a managed token."
    },
    "IProofFileResponse": {
      "description": "Definition of a transaction (proof file). It is an entity that hold the events.",
      "type": "object",
      "properties": {
        "client_id": {
          "description": "Client identifier of the user that is initiating the transaction.",
          "type": "string",
          "readOnly": true
        },
        "entity_id": {
          "format": "uuid",
          "description": "The DocuSign entity identifier.",
          "type": "string",
          "readOnly": true
        },
        "entity_type": {
          "description": "Type of the entity. i.e room, user, envelope...",
          "type": "string",
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IProofFileResponse",
      "x-ms-summary": "Definition of a transaction (proof file). It is an entity that hold the events."
    },
    "IViewSchemasResponse": {
      "description": "",
      "type": "object",
      "properties": {
        "view_schemas": {
          "description": "List of the view schema.",
          "uniqueItems": true,
          "type": "array",
          "items": {
            "$ref": "#/definitions/IViewSchemaResponse"
          },
          "readOnly": true
        },
        "paging": {
          "$ref": "#/definitions/IPaginated",
          "description": "Paging info.",
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IViewSchemasResponse",
      "x-ms-summary": ""
    },
    "IViewSchemaResponse": {
      "description": "Definition of a view schema. The view schema is used to filter the data thar are given back by the proof service.",
      "type": "object",
      "properties": {
        "data": {
          "description": "JSON based format representing the data to render.",
          "type": "object",
          "readOnly": true
        },
        "schema_id": {
          "format": "uuid",
          "description": "View schema identifier.",
          "type": "string",
          "readOnly": true
        },
        "entity_type": {
          "description": "Type of the entity. i.e room, user, envelope...",
          "type": "string",
          "readOnly": true
        },
        "event_type": {
          "description": "Type of the event. This property depends on the source, the creator of an event. The proof service does not have any pre-establish list of events types.\r\nIt is totally up to the external service, that calls the proof service, to decide and manage their events types.",
          "type": "string",
          "readOnly": true
        },
        "authority": {
          "description": "Audience or authority claiming the data.",
          "type": "string",
          "readOnly": true
        },
        "data_model_validation_version": {
          "format": "int32",
          "description": "Gets or sets the version of the data model the view schema is bound to.",
          "type": "integer",
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IViewSchemaResponse",
      "x-ms-summary": "Definition of a view schema. The view schema is used to filter the data thar are given back by the proof service."
    },
    "PostViewSchemaBody": {
      "description": "Model representing the object passed to the insert view schema endpoint.",
      "required": [
        "entity_type",
        "event_type",
        "data",
        "authority",
        "data_model_validation_version"
      ],
      "type": "object",
      "properties": {
        "entity_type": {
          "description": "Type of the entity. i.e room, user, envelope...",
          "type": "string"
        },
        "event_type": {
          "description": "Type of the event. This property depends on the source, the creator of an event. The proof service does not have any pre-establish list of events types.\r\nIt is totally up to the external service, that calls the proof service, to decide and manage their events types.",
          "type": "string"
        },
        "data": {
          "description": "JSON based format representing the data to render. It's a partial part of the validation schema it is bound to.",
          "type": "object"
        },
        "authority": {
          "description": "Audience or authority who can access the schema. It could be a title like \"judge\", a denomination like \"sender\", or any label you want like \"everyone\" or \"level one of sensitiveness\". \r\nThis definition is up to the external service to define and to manage. However it is a mandatory field in the view schema definition.",
          "type": "string"
        },
        "data_model_validation_version": {
          "format": "int32",
          "description": "Data model validation version. This object is bound to a data model validation schema at a specified version.",
          "maximum": 2147483647,
          "minimum": 0,
          "type": "integer"
        }
      },
      "x-ds-definition-name": "PostViewSchemaBody",
      "x-ms-summary": "Model representing the object passed to the insert view schema endpoint."
    },
    "PutViewSchemaBody": {
      "description": "Model representing the object passed to the update view schema endpoint.",
      "required": [
        "data"
      ],
      "type": "object",
      "properties": {
        "data": {
          "description": "JSON based format representing the data to render.",
          "type": "object"
        }
      },
      "x-ds-definition-name": "PutViewSchemaBody",
      "x-ms-summary": "Model representing the object passed to the update view schema endpoint."
    },
    "Events": {
      "description": "Events pushed to ID Evidence.",
      "type": "object",
      "properties": {
        "events": {
          "description": "List of the events contained in the transaction.",
          "uniqueItems": false,
          "type": "array",
          "items": {
            "$ref": "#/definitions/IEventResponse"
          },
          "readOnly": true
        },
        "paging": {
          "$ref": "#/definitions/IPaginated",
          "description": "Paging info.",
          "readOnly": true
        }
      },
      "x-ds-definition-name": "IEventsResponse",
      "x-ds-category": "IDEvidence",
      "x-ds-order": "1",
      "x-ms-summary": "Events pushed to ID Evidence."
    }
  },
  "securityDefinitions": {
    "Bearer": {
      "name": "Authorization",
      "in": "header",
      "type": "apiKey",
      "description": "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\""
    }
  },
  "security": [
    {
      "Bearer": []
    }
  ],
  "tags": [
    {
      "name": "Events",
      "description": "The Events resource provides methods that enable you to retrieve identification events and export events data."
    }
  ],
  "x-ds-categories": [
    {
      "name": "IDEvidence",
      "summary": "This section shows you how to retrieve identification events triggered in ID Verification. It also shows you how to export events data to various formats.",
      "description": "If you're using ID Verification to verify the identity of your recipients, you can use the ID Evidence API to store the identification data you want. You can also export stored data, such as first name, last name, date of birth, expiration date, or copies of scanned IDs to various formats."
    }
  ]
}